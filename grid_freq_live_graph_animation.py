import requests
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.animation import FuncAnimation
from datetime import datetime, timezone, timedelta

from functools import partial
import pandas


## grid_freq_live_graph_animation.py
## Bessam Saleh MEng Team 3 2023-2024
## Overlays Elexon data with local frequency estimation in a live plot.
## This program uses the logged CSV data from the Python data logger
## Run serial_freq_data_logger.py before using this program to ensure compatibility
## Program can be adapted to show only Elexon data if desired
# Most of the code is to make it look nice for the demo.
# Main program simply checks for new serial-received CSV data every second,
# and checks for new Elexon data using BMRS API every 10 seconds.

## This demo version starts the Elexon graph from T=now.
## Also, all of the previously obtained data can be shown if the graph is zoomed out.
## The default view is last 30 minutes.

## TODO: add lines at system boundaries with a key
## NEED TO HANDLE EXCEPTIONS FROM REQUESTS TIMEOUT (switch off internet)


def GetLatestElexonData(xminutes):
    # Get current time and time - X minutes
    timeNow = datetime.now(timezone.utc)
    timeBefore = datetime.now(timezone.utc) - timedelta(minutes=xminutes)

    str_timeNow = timeNow.isoformat(timespec='seconds')
    str_timeNow = str_timeNow.split('+',1)[0]
    str_timeBefore = timeBefore.isoformat(timespec='seconds')
    str_timeBefore = str_timeBefore.split('+',1)[0]

    # Specify format of requested data (json, xml, csv)
    outputFormat = 'json'

    # Create the url from which to make the get request, using above variables
    url = "https://data.elexon.co.uk/bmrs/api/v1/datasets/FREQ?measurementDateTimeFrom={0}&measurementDateTimeTo={1}&format={2}".format(
        str_timeBefore, str_timeNow, outputFormat)

    # Get data from url
    try:
        response = requests.get(url)
        data = response.json()
        #print(data)
        return data, timeNow
    except Exception as err:
        print(err)
        return err

def ConvertElexonToDateTimeOrdered(responseData):
    # Format the Elexon data from the get request
    contents = responseData['data']
    datetimestamps = [i['measurementTime'] for i in contents]
    datetimestamps.reverse()
    freqs = [i['frequency'] for i in contents]
    freqs.reverse()
    # Convert to datetime and UTC timezone
    datetimestamps = [datetime.strptime(i, '%Y-%m-%d''T''%H:%M:%S''Z').replace(tzinfo=timezone.utc)
                  for i in datetimestamps]
    return datetimestamps, freqs

def init():
    print('starting plot')
    # Ticks along the x-axis will be every 5 minutes by default
    # Timezone of x-axis is based on the bstOffset variable (can be changed)
    ax.xaxis.set(major_locator=mdates.MinuteLocator(interval=5),
                 major_formatter=mdates.DateFormatter("%H:%M", tz = timezone(bstOffset)),
                 minor_locator=mdates.MinuteLocator(interval=1))
    # Add any extra code that runs at the first FuncAnimation loop

## The update function is called by the FuncAnimation artists
# First argument is required by the subclass but not used in this implementation
def update(frame, artist):
    if artist == lnElexon:
        # Get last 5 minutes of Elexon data
        dataRecent = GetLatestElexonData(5)[0]
        datetimestampsRecent, freqsRecent = ConvertElexonToDateTimeOrdered(dataRecent)
        # Add any data which isn't already present to the line object
        for i in range(len(datetimestampsRecent)):
            if datetimestampsRecent[i] not in datetimestamps:
                datetimestamps.append(datetimestampsRecent[i])
                freqs.append(freqsRecent[i])
        lnElexon.set_data(datetimestamps, freqs)
#        ax.relim()
#        ax.autoscale_view()
        print(i)
        return lnElexon,

    elif artist == lnSerial:
        # Read the data from CSV file generated by separate data logger script
        dataSerial = pandas.read_csv('serial_received_data.csv')
        serial_datetimestamps = pandas.to_datetime(dataSerial['Datetime'],
                                                   format='ISO8601')
#       Hacky way of accounting for timezone differences
        serial_datetimestamps = serial_datetimestamps - bstOffset
        # Add data to line object
        lnSerial.set_data(serial_datetimestamps, dataSerial.Frequency)
        custom_xlim = ax.get_xlim()
        # Show last 30 mins if user is not controlling figure view
        if ax.get_navigate_mode() == None:
            custom_xlim = ax.get_xlim()
            ## To do: Insert some condition to check if this tick locator reset is needed
            ax.xaxis.set(major_locator=mdates.MinuteLocator(interval=5),
                        minor_locator=mdates.MinuteLocator(interval=1))
            # Set graph view to last 30 minutes
            ax.set_xlim([serial_datetimestamps.iat[-1] - timedelta(minutes=30), serial_datetimestamps.iat[-1]])
            ax.set_ylim([49.8, 50.2])
        else:
            # If user is controlling the figure view (eg zoom/pan control), change the appearance of ticks
            custom_xlim = ax.get_xlim()
            delta_xlim = mdates.num2timedelta(custom_xlim[1] - custom_xlim[0])
            if delta_xlim.seconds > 60*60:
                if delta_xlim.seconds > 180*60:
                    ax.xaxis.set(major_locator=mdates.HourLocator(),
                                 minor_locator=mdates.MinuteLocator(byminute=[15,30,45]))
                else:
                    ax.xaxis.set(major_locator=mdates.MinuteLocator(interval=15),
                                minor_locator=mdates.MinuteLocator(interval=5))
                #ax.autoscale
        return lnSerial,

# Creates a timedelta object to represent the difference in time from UTC
# Not smart - should be changed depending if daylight savings are used
bstOffset = timedelta(hours=0)

# Empty lists to store the Elexon data
datetimestamps = []
freqs = []

# Set up the matplotlib graphs
fig, ax = plt.subplots()
lnElexon, = ax.plot([], [])
lnSerial, = ax.plot([], [])


#Remove whitespace from left/right side of graphs
ax.margins(x=0)
#ax.axhline(y=50.2)     # Can be used to add lines at operational frequency limits
ax.set_ylim([49.8, 50.2])
ax.legend(['Official Elexon frequency data','Estimate of local frequency'], loc='upper left')
plt.title('Live grid frequency data')
plt.xlabel('Clock Time')
plt.ylabel('Frequency (Hz)')

timeStart = datetime.now()

# Create the FuncAnimation subclasses, which call the update function at fixed intervals
# Use of partial() allows extra arguments to be passed to update()
aniElexon = FuncAnimation(fig, partial(update, artist=lnElexon), interval=10*1000, init_func=init, cache_frame_data=False)
aniSerial = FuncAnimation(fig, partial(update, artist=lnSerial), interval=1*1000, cache_frame_data=False)

plt.show()
